using System;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using DerivCTrader.Infrastructure.CTrader;
using DerivCTrader.Infrastructure.CTrader.Interfaces;
using DerivCTrader.Infrastructure.CTrader.Models;
using Google.Protobuf;
using Microsoft.Extensions.Logging;
using Moq;
using Xunit;
// Ensure we use the ProtoOASpotEvent from OpenAPI.Net if available, 
// otherwise we assume the project generates it or we provided dummy.
// Given the user instructions, we assume it's available or we should use the dummy if fails.
// BUT the user said "Real Protobuf serialization... use real ProtoOASpotEvent generated by Protobuf".
// This implies using "OpenAPI.Net".
using OpenAPI.Net;

namespace DerivCTrader.Infrastructure.Tests
{
    // Use local enum to resolve PayloadType ambiguity and ensure values match SUT expectation
    public enum ProtoOAPayloadType
    {
        ProtoOaSpotEvent = 2136,
        ProtoOaSubscribeSpotsRes = 2134,
        ProtoOaErrorRes = 50
    }

    public class CTraderOrderManagerTests
    {
        private readonly Mock<ILogger<CTraderOrderManager>> _loggerMock;
        private readonly Mock<ICTraderClient> _clientMock;
        private readonly Mock<ICTraderSymbolService> _symbolServiceMock;
        private readonly Mock<Microsoft.Extensions.Configuration.IConfiguration> _configurationMock;
        private readonly CTraderOrderManager _orderManager;

        public CTraderOrderManagerTests()
        {
            _loggerMock = new Mock<ILogger<CTraderOrderManager>>();
            _clientMock = new Mock<ICTraderClient>();
            _symbolServiceMock = new Mock<ICTraderSymbolService>();
            _configurationMock = new Mock<Microsoft.Extensions.Configuration.IConfiguration>();

            // Setup default configuration
            var ctSection = new Mock<Microsoft.Extensions.Configuration.IConfigurationSection>();
            ctSection.Setup(s => s["DefaultLotSize"]).Returns("0.2");
            _configurationMock.Setup(c => c.GetSection("CTrader")).Returns(ctSection.Object);

            _orderManager = new CTraderOrderManager(
                _loggerMock.Object,
                _clientMock.Object,
                _symbolServiceMock.Object,
                _configurationMock.Object
            );
        }

        private delegate void TryGetSymbolDigitsCallback(long id, out int digits);

        [Fact]
        public async Task GetCurrentBidAskAsync_ReturnsBidAsk_WhenSpotEventReceived()
        {
            // Arrange
            var symbol = "Volatility 25 Index";
            ulong symbolId = 12345;
            double bid = 100.50;
            double ask = 100.55;

            // Mocks
            _clientMock.Setup(c => c.IsConnected).Returns(true);
            _clientMock.Setup(c => c.IsAccountAuthenticated).Returns(true);
            _clientMock.Setup(c => c.AccountId).Returns(123456);

            _symbolServiceMock.Setup(s => s.HasSymbol(symbol)).Returns(true);
            _symbolServiceMock.Setup(s => s.GetSymbolId(symbol)).Returns((long)symbolId);
            _symbolServiceMock.Setup(s => s.GetDigits((long)symbolId)).Returns(2);

            // Correct Moq out parameter setup for TryGetSymbolDigits (set out value and return true)
            _symbolServiceMock.Setup(s => s.TryGetSymbolDigits(It.IsAny<long>(), out It.Ref<int>.IsAny))
                .Callback((long id, out int digits) => { digits = 2; })
                .Returns(true);

            _clientMock.Setup(c => c.SendMessageAsync(
                It.IsAny<object>(),
                It.IsAny<int>(),
                It.IsAny<CancellationToken>()
            )).Returns(Task.CompletedTask);


            EventHandler<CTraderMessage>? attachedHandler = null;
            _clientMock.SetupAdd(c => c.MessageReceived += It.IsAny<EventHandler<CTraderMessage>>())
                .Callback<EventHandler<CTraderMessage>>(h => attachedHandler = h);

            // Act: Start the SUT's async method (which attaches the handler)
            var actTask = _orderManager.GetCurrentBidAskAsync(symbol);

            // Wait a moment to ensure handler is attached
            await Task.Delay(50);

            // Now fire the event so the SUT's handler receives it
            var spotEvent = new ProtoOASpotEvent
            {
                SymbolId = (long)symbolId,
                Bid = (ulong)(bid * 100), // digits=2, so multiply by 100
                Ask = (ulong)(ask * 100)  // digits=2, so multiply by 100
            };
            var payload = spotEvent.ToByteArray();
            var msg = new CTraderMessage
            {
                PayloadType = (int)ProtoOAPayloadType.ProtoOaSpotEvent,
                Payload = payload
            };
            attachedHandler?.Invoke(null, msg);

            var result = await actTask;

            // Assert
            Assert.NotNull(result.Bid);
            Assert.NotNull(result.Ask);
            Assert.True(result.Bid > 0);
            Assert.True(result.Ask > 0);
        }
    }
}