# ========================================================
# Azure DevOps Pipeline for DerivCTraderAutomation
# Windows Service Deployment
# FIXED - Matches KhulaFxTradeMonitor Authentication
# ========================================================

trigger:
  branches:
    include:
      - master
      - main

variables:
  - group: Deployment-Secrets
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '8.x'
  - name: serviceNameScraper
    value: 'DerivCTraderSignalScraper'
  - name: serviceNameExecutor
    value: 'DerivCTraderTradeExecutor'
  - name: deployPathScraper
    value: 'C:\Services\DerivCTraderSignalScraper'
  - name: deployPathExecutor
    value: 'C:\Services\DerivCTraderTradeExecutor'
  - name: vpsServer
    value: '108.181.161.170'

stages:
# ================================
# BUILD STAGE
# ================================
- stage: Build
  displayName: 'Build DerivCTrader Services'
  jobs:
  - job: BuildJob
    displayName: 'Build Applications'
    pool:
      name: 'Default'
    steps:
    - checkout: self
      fetchDepth: 1

    - task: UseDotNet@2
      displayName: 'Install .NET SDK 8.x'
      inputs:
        packageType: sdk
        version: $(dotnetVersion)

    # -----------------------------
    # Publish SignalScraper Service
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Publish SignalScraper Service'
      inputs:
        targetType: inline
        script: |
          $publishFolder = "$(Build.ArtifactStagingDirectory)\signalscraper"
          Write-Host "Publishing SignalScraper to $publishFolder"

          dotnet publish "$(Build.SourcesDirectory)\src\DerivCTrader.SignalScraper\DerivCTrader.SignalScraper.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$publishFolder"

          if (!(Test-Path $publishFolder)) {
            Write-Error "Publish folder not found: $publishFolder"
            exit 1
          }
          
          # CRITICAL: Verify appsettings.Production.json was copied
          Write-Host "`n=== CHECKING FOR CONFIG FILES ===" -ForegroundColor Cyan
          Write-Host "Looking in: $publishFolder"
          
          if (Test-Path "$publishFolder\appsettings.Production.json") {
            Write-Host "✅ appsettings.Production.json EXISTS" -ForegroundColor Green
          } else {
            Write-Host "❌ appsettings.Production.json MISSING!" -ForegroundColor Red
            Write-Host "`nFiles in publish folder:"
            Get-ChildItem $publishFolder | Select-Object Name, Length | Format-Table
            
            Write-Host "`nChecking source project folder:"
            $sourceConfig = "$(Build.SourcesDirectory)\src\DerivCTrader.SignalScraper\appsettings.Production.json"
            if (Test-Path $sourceConfig) {
              Write-Host "✅ Config file EXISTS in source: $sourceConfig" -ForegroundColor Yellow
              Write-Host "⚠️ But it's NOT being copied to publish folder!" -ForegroundColor Red
              Write-Host "`nCheck your .csproj file for:"
              Write-Host "  <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>"
            } else {
              Write-Host "❌ Config file MISSING from source: $sourceConfig" -ForegroundColor Red
            }
            exit 1
          }

    # -----------------------------
    # Publish TradeExecutor Service
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Publish TradeExecutor Service'
      inputs:
        targetType: inline
        script: |
          $publishFolder = "$(Build.ArtifactStagingDirectory)\tradeexecutor"
          Write-Host "Publishing TradeExecutor to $publishFolder"

          dotnet publish "$(Build.SourcesDirectory)\src\DerivCTrader.TradeExecutor\DerivCTrader.TradeExecutor.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$publishFolder"

          if (!(Test-Path $publishFolder)) {
            Write-Error "Publish folder not found: $publishFolder"
            exit 1
          }
          
          # CRITICAL: Verify appsettings.Production.json was copied
          Write-Host "`n=== CHECKING FOR CONFIG FILES ===" -ForegroundColor Cyan
          Write-Host "Looking in: $publishFolder"
          
          if (Test-Path "$publishFolder\appsettings.Production.json") {
            Write-Host "✅ appsettings.Production.json EXISTS" -ForegroundColor Green
          } else {
            Write-Host "❌ appsettings.Production.json MISSING!" -ForegroundColor Red
            Write-Host "`nFiles in publish folder:"
            Get-ChildItem $publishFolder | Select-Object Name, Length | Format-Table
            
            Write-Host "`nChecking source project folder:"
            $sourceConfig = "$(Build.SourcesDirectory)\src\DerivCTrader.TradeExecutor\appsettings.Production.json"
            if (Test-Path $sourceConfig) {
              Write-Host "✅ Config file EXISTS in source: $sourceConfig" -ForegroundColor Yellow
              Write-Host "⚠️ But it's NOT being copied to publish folder!" -ForegroundColor Red
              Write-Host "`nCheck your .csproj file for:"
              Write-Host "  <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>"
            } else {
              Write-Host "❌ Config file MISSING from source: $sourceConfig" -ForegroundColor Red
            }
            exit 1
          }

    # -----------------------------
    # Verify Build Output
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Verify SignalScraper Build'
      inputs:
        targetType: inline
        script: |
          $artifactPath = "$(Build.ArtifactStagingDirectory)\signalscraper"
          
          # Check DLL
          $dllPath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.SignalScraper.dll" -Recurse | Select-Object -First 1
          if ($dllPath) {
            Write-Host "✅ DLL found: $($dllPath.FullName)" -ForegroundColor Green
          } else {
            Write-Error "❌ DerivCTrader.SignalScraper.dll not found"
            exit 1
          }
          
          # Check appsettings.json
          if (Test-Path "$artifactPath\appsettings.json") {
            Write-Host "✅ appsettings.json found" -ForegroundColor Green
          } else {
            Write-Warning "⚠️ appsettings.json not found"
          }
          
          # Check appsettings.Production.json
          if (Test-Path "$artifactPath\appsettings.Production.json") {
            Write-Host "✅ appsettings.Production.json found" -ForegroundColor Green
          } else {
            Write-Error "❌ appsettings.Production.json NOT FOUND - Service will fail to start!"
            Write-Host "Files in artifact:"
            Get-ChildItem $artifactPath | Select-Object Name
            exit 1
          }

    - task: PowerShell@2
      displayName: 'Verify TradeExecutor Build'
      inputs:
        targetType: inline
        script: |
          $artifactPath = "$(Build.ArtifactStagingDirectory)\tradeexecutor"
          
          # Check DLL
          $dllPath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.TradeExecutor.dll" -Recurse | Select-Object -First 1
          if ($dllPath) {
            Write-Host "✅ DLL found: $($dllPath.FullName)" -ForegroundColor Green
          } else {
            Write-Error "❌ DerivCTrader.TradeExecutor.dll not found"
            exit 1
          }
          
          # Check appsettings.json
          if (Test-Path "$artifactPath\appsettings.json") {
            Write-Host "✅ appsettings.json found" -ForegroundColor Green
          } else {
            Write-Warning "⚠️ appsettings.json not found"
          }
          
          # Check appsettings.Production.json
          if (Test-Path "$artifactPath\appsettings.Production.json") {
            Write-Host "✅ appsettings.Production.json found" -ForegroundColor Green
          } else {
            Write-Error "❌ appsettings.Production.json NOT FOUND - Service will fail to start!"
            Write-Host "Files in artifact:"
            Get-ChildItem $artifactPath | Select-Object Name
            exit 1
          }

    # -----------------------------
    # Publish Artifacts
    # -----------------------------
    - task: PublishBuildArtifacts@1
      displayName: 'Publish SignalScraper Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/signalscraper'
        artifactName: 'signalscraper'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish TradeExecutor Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/tradeexecutor'
        artifactName: 'tradeexecutor'
        publishLocation: 'Container'

# ================================
# DEPLOY STAGE
# ================================
- stage: Deploy
  displayName: 'Deploy to VPS'
  dependsOn: Build
  jobs:
  - deployment: DeployServices
    displayName: 'Deploy Both Services'
    environment: 'VPS-Production'
    pool:
      name: 'Default'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: signalscraper

          - download: current
            artifact: tradeexecutor

          # ================================
          # AUTHENTICATION - EXACT COPY FROM KhulaFxTradeMonitor
          # ================================
          - task: PowerShell@2
            displayName: 'Test Authentication'
            inputs:
              targetType: inline
              script: |
                $server = "$(vpsServer)"
                $usernameVariants = @(".\$(deployUser)", "$(deployUser)")
                $authMethods = @("Negotiate", "Default")
                $found = $false

                foreach ($auth in $authMethods) {
                  foreach ($user in $usernameVariants) {
                    Write-Host "Trying $auth as $user..."
                    try {
                      $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                      $cred = New-Object PSCredential ($user, $secPass)
                      $s = New-PSSession -ComputerName $server -Authentication $auth -Credential $cred -ErrorAction Stop
                      Write-Host "✅ Success with $auth as $user"
                      Write-Host "##vso[task.setvariable variable=SuccessfulUserName;isOutput=true]$user"
                      Write-Host "##vso[task.setvariable variable=SuccessfulAuth;isOutput=true]$auth"
                      Remove-PSSession $s
                      $found = $true
                      break
                    } catch {
                      Write-Host "❌ Failed"
                    }
                  }
                  if ($found) { break }
                }

                if (-not $found) {
                  Write-Error "Authentication failed"
                  exit 1
                }
            name: AuthTest

          # ================================
          # Deploy SignalScraper Service
          # ================================
          - task: PowerShell@2
            displayName: 'Deploy SignalScraper Service'
            inputs:
              targetType: inline
              script: |
                $server = "$(vpsServer)"
                $deployPath = "$(deployPathScraper)"
                $serviceName = "$(serviceNameScraper)"
                $artifactPath = "$(Pipeline.Workspace)/signalscraper"

                Write-Host "Deploying to: $deployPath"

                $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
                $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)

                try {
                  # Stop service
                  Write-Host "Stopping service..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($svc)
                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service -and $service.Status -eq 'Running') {
                      Stop-Service -Name $svc -Force
                      Start-Sleep -Seconds 5
                      Write-Host "Service stopped"
                    }
                  } -ArgumentList $serviceName

                  # Backup session files
                  Write-Host "Backing up Telegram session files..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    if (Test-Path $path) {
                      $backupPath = "$path\session_backup"
                      if (-not (Test-Path $backupPath)) { 
                        New-Item -ItemType Directory -Path $backupPath -Force | Out-Null 
                      }
                      Get-ChildItem -Path $path -Filter "*.session" | ForEach-Object {
                        Copy-Item $_.FullName -Destination $backupPath -Force
                        Write-Host "Backed up: $($_.Name)"
                      }
                    }
                  } -ArgumentList $deployPath

                  # Prepare directory
                  Write-Host "Preparing directory..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    if (-not (Test-Path $path)) { New-Item -ItemType Directory -Path $path -Force | Out-Null }
                    Get-ChildItem -Path $path | Where-Object { $_.Name -notmatch 'log|backup|\.session|charts' } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                    Write-Host "Directory ready"
                  } -ArgumentList $deployPath

                  # Copy files
                  Write-Host "Copying files..."
                  Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
                  Write-Host "Files copied"

                  # Restore session files
                  Write-Host "Restoring Telegram session files..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    $backupPath = "$path\session_backup"
                    if (Test-Path $backupPath) {
                      Get-ChildItem -Path $backupPath -Filter "*.session" | ForEach-Object {
                        Copy-Item $_.FullName -Destination $path -Force
                        Write-Host "Restored: $($_.Name)"
                      }
                    }
                  } -ArgumentList $deployPath

                  # Install/start as Scheduled Task (more reliable than Windows Service)
                  Write-Host "Creating Scheduled Task..."
                  $result = Invoke-Command -Session $session -ScriptBlock {
                    param($svc, $path)
                    
                    $exe = Get-ChildItem -Path $path -Filter "DerivCTrader.SignalScraper.exe" -ErrorAction SilentlyContinue
                    if (-not $exe) {
                      $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                        Where-Object { $_.Name -notlike "createdump*" } |
                        Sort-Object Length -Descending | 
                        Select-Object -First 1
                    }
                    if (-not $exe) { throw "Executable not found" }

                    $binaryPath = $exe.FullName
                    Write-Host "Executable: $binaryPath"
                    
                    # Delete old Windows Service if it exists
                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service) {
                      Write-Host "Removing old Windows Service..."
                      sc.exe delete $svc | Out-Null
                      Start-Sleep -Seconds 2
                    }
                    
                    # Remove old scheduled task if it exists
                    Unregister-ScheduledTask -TaskName $svc -Confirm:$false -ErrorAction SilentlyContinue
                    
                    # Create scheduled task
                    Write-Host "Creating Scheduled Task..."
                    $action = New-ScheduledTaskAction -Execute $binaryPath -Argument "--contentRoot `"$path`"" -WorkingDirectory $path
                    $trigger = New-ScheduledTaskTrigger -AtStartup
                    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable -RestartInterval (New-TimeSpan -Minutes 1) -RestartCount 999
                    $principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
                    
                    Register-ScheduledTask -TaskName $svc -Action $action -Trigger $trigger -Settings $settings -Principal $principal -Force | Out-Null

                    Write-Host "Starting Scheduled Task..."
                    try {
                      Start-ScheduledTask -TaskName $svc -ErrorAction Stop
                      Start-Sleep -Seconds 15
                      
                      # Check if process is running
                      $process = Get-Process | Where-Object { $_.Path -eq $binaryPath } -ErrorAction SilentlyContinue
                      $taskInfo = Get-ScheduledTask -TaskName $svc
                      
                      if ($process) {
                        Write-Host "✅ Task running (PID: $($process.Id))"
                        return @{ Success = $true; Status = "Running"; ProcessId = $process.Id }
                      } elseif ($taskInfo.State -eq "Running") {
                        Write-Host "✅ Task started"
                        return @{ Success = $true; Status = "Running" }
                      } else {
                        Write-Host "⚠️ Task state: $($taskInfo.State)"
                        return @{ Success = $false; Status = $taskInfo.State; Error = "Task not running" }
                      }
                    } catch {
                      Write-Host "❌ Failed to start task: $_"
                      return @{ Success = $false; Status = "Stopped"; Error = $_.Exception.Message }
                    }
                  } -ArgumentList $serviceName, $deployPath

                  if (-not $result.Success) {
                    Write-Warning "Service deployment completed but service is not running"
                    Write-Warning "Error: $($result.Error)"
                  }
                } finally {
                  Remove-PSSession $session
                }

          # ================================
          # Deploy TradeExecutor Service
          # ================================
          - task: PowerShell@2
            displayName: 'Deploy TradeExecutor Service'
            inputs:
              targetType: inline
              script: |
                $server = "$(vpsServer)"
                $deployPath = "$(deployPathExecutor)"
                $serviceName = "$(serviceNameExecutor)"
                $artifactPath = "$(Pipeline.Workspace)/tradeexecutor"

                Write-Host "Deploying to: $deployPath"

                $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
                $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)

                try {
                  # Stop service
                  Write-Host "Stopping service..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($svc)
                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service -and $service.Status -eq 'Running') {
                      Stop-Service -Name $svc -Force
                      Start-Sleep -Seconds 5
                      Write-Host "Service stopped"
                    }
                  } -ArgumentList $serviceName

                  # Prepare directory
                  Write-Host "Preparing directory..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    if (-not (Test-Path $path)) { New-Item -ItemType Directory -Path $path -Force | Out-Null }
                    Get-ChildItem -Path $path | Where-Object { $_.Name -notmatch 'log|backup|charts' } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                    Write-Host "Directory ready"
                  } -ArgumentList $deployPath

                  # Copy files
                  Write-Host "Copying files..."
                  Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
                  Write-Host "Files copied"

                  # Install/start as Scheduled Task (more reliable than Windows Service)
                  Write-Host "Creating Scheduled Task..."
                  $result = Invoke-Command -Session $session -ScriptBlock {
                    param($svc, $path)
                    
                    $exe = Get-ChildItem -Path $path -Filter "DerivCTrader.TradeExecutor.exe" -ErrorAction SilentlyContinue
                    if (-not $exe) {
                      $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                        Where-Object { $_.Name -notlike "createdump*" } |
                        Sort-Object Length -Descending | 
                        Select-Object -First 1
                    }
                    if (-not $exe) { throw "Executable not found" }

                    $binaryPath = $exe.FullName
                    Write-Host "Executable: $binaryPath"
                    
                    # Delete old Windows Service if it exists
                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service) {
                      Write-Host "Removing old Windows Service..."
                      sc.exe delete $svc | Out-Null
                      Start-Sleep -Seconds 2
                    }
                    
                    # Remove old scheduled task if it exists
                    Unregister-ScheduledTask -TaskName $svc -Confirm:$false -ErrorAction SilentlyContinue
                    
                    # Create scheduled task
                    Write-Host "Creating Scheduled Task..."
                    $action = New-ScheduledTaskAction -Execute $binaryPath -Argument "--contentRoot `"$path`"" -WorkingDirectory $path
                    $trigger = New-ScheduledTaskTrigger -AtStartup
                    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable -RestartInterval (New-TimeSpan -Minutes 1) -RestartCount 999
                    $principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
                    
                    Register-ScheduledTask -TaskName $svc -Action $action -Trigger $trigger -Settings $settings -Principal $principal -Force | Out-Null

                    Write-Host "Starting Scheduled Task..."
                    try {
                      Start-ScheduledTask -TaskName $svc -ErrorAction Stop
                      Start-Sleep -Seconds 15
                      
                      # Check if process is running
                      $process = Get-Process | Where-Object { $_.Path -eq $binaryPath } -ErrorAction SilentlyContinue
                      $taskInfo = Get-ScheduledTask -TaskName $svc
                      
                      if ($process) {
                        Write-Host "✅ Task running (PID: $($process.Id))"
                        return @{ Success = $true; Status = "Running"; ProcessId = $process.Id }
                      } elseif ($taskInfo.State -eq "Running") {
                        Write-Host "✅ Task started"
                        return @{ Success = $true; Status = "Running" }
                      } else {
                        Write-Host "⚠️ Task state: $($taskInfo.State)"
                        return @{ Success = $false; Status = $taskInfo.State; Error = "Task not running" }
                      }
                    } catch {
                      Write-Host "❌ Failed to start task: $_"
                      return @{ Success = $false; Status = "Stopped"; Error = $_.Exception.Message }
                    }
                  } -ArgumentList $serviceName, $deployPath

                  if (-not $result.Success) {
                    Write-Warning "Service deployment completed but service is not running"
                    Write-Warning "Error: $($result.Error)"
                  }
                } finally {
                  Remove-PSSession $session
                }

          # ================================
          # Check Application Logs
          # ================================
          - task: PowerShell@2
            displayName: 'Check SignalScraper Logs'
            condition: always()
            inputs:
              targetType: inline
              script: |
                Write-Host "Checking application logs..."
                $server = "$(vpsServer)"
                $deployPath = "$(deployPathScraper)"
                
                $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
                
                try {
                  $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)
                  
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    
                    $logPath = Join-Path $path "Logs"
                    
                    if (Test-Path $logPath) {
                      $latestLog = Get-ChildItem -Path $logPath -Filter "*.txt" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                      
                      if ($latestLog) {
                        Write-Host "`nLatest log file: $($latestLog.Name)"
                        Write-Host "Last 30 lines:"
                        Write-Host "=" * 80
                        Get-Content $latestLog.FullName -Tail 30
                        Write-Host "=" * 80
                      } else {
                        Write-Host "No log files found in Logs directory"
                      }
                    } else {
                      Write-Host "Logs directory not found at: $logPath"
                      Write-Host "This is normal if service hasn't started yet"
                    }
                  } -ArgumentList $deployPath
                  
                  Remove-PSSession $session
                } catch {
                  Write-Warning "Could not read logs: $_"
                }

# ================================
# NOTIFY STAGE
# ================================
- stage: Notify
  displayName: 'Send Notification'
  dependsOn: Deploy
  condition: always()
  jobs:
  - job: SendNotification
    pool:
      name: 'Default'
    steps:
    - task: PowerShell@2
      displayName: 'Telegram Notification'
      inputs:
        targetType: inline
        script: |
          $status = if ("$(Agent.JobStatus)" -eq "Succeeded") { "✅ SUCCESS" } else { "❌ FAILED" }
          $message = @"
          *DerivCTrader Deployment*
          
          Status: $status
          Server: $(vpsServer)
          Path (Scraper): $(deployPathScraper)
          Path (Executor): $(deployPathExecutor)
          Build: $(Build.BuildNumber)
          
          [View Logs]($(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId))
          "@
          
          $url = "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage"
          $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
          
          try {
            Invoke-RestMethod -Uri $url -Method Post -ContentType "application/json; charset=utf-8" -Body ([System.Text.Encoding]::UTF8.GetBytes($body))
            Write-Host "✅ Notification sent"
          } catch {
            Write-Warning "Notification failed"
          }