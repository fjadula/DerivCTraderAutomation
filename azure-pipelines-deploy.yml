# ========================================================
# Azure DevOps Pipeline for DerivCTraderAutomation
# SIMPLIFIED - No Environment Dependencies
# ========================================================

trigger:
  branches:
    include:
      - master
      - main

variables:
  - group: Deployment-Secrets
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '8.x'
  - name: serviceNameScraper
    value: 'DerivCTraderSignalScraper'
  - name: serviceNameExecutor
    value: 'DerivCTraderTradeExecutor'
  - name: deployPathScraper
    value: 'C:\Services\DerivCTraderSignalScraper'
  - name: deployPathExecutor
    value: 'C:\Services\DerivCTraderTradeExecutor'
  - name: vpsServer
    value: '108.181.161.170'
  - name: deployUser
    value: 'Administrator'

# ================================
# SINGLE STAGE PIPELINE
# Build and Deploy in one go
# ================================
stages:
- stage: BuildAndDeploy
  displayName: 'Build and Deploy DerivCTrader'
  jobs:
  # ================================
  # BUILD JOB
  # ================================
  - job: Build
    displayName: 'Build Services'
    pool:
      name: 'Default'
    steps:
    - checkout: self
      fetchDepth: 1

    - task: UseDotNet@2
      displayName: 'Install .NET SDK 8.x'
      continueOnError: true
      inputs:
        packageType: sdk
        version: $(dotnetVersion)

    # Publish SignalScraper
    - task: PowerShell@2
      displayName: 'Publish SignalScraper'
      inputs:
        targetType: inline
        script: |
          Write-Host "Publishing SignalScraper..." -ForegroundColor Cyan
          dotnet publish "$(Build.SourcesDirectory)\src\DerivCTrader.SignalScraper\DerivCTrader.SignalScraper.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$(Build.ArtifactStagingDirectory)\signalscraper"
          
          if ($LASTEXITCODE -ne 0) { exit 1 }
          Write-Host "✅ SignalScraper published" -ForegroundColor Green

    # Publish TradeExecutor
    - task: PowerShell@2
      displayName: 'Publish TradeExecutor'
      inputs:
        targetType: inline
        script: |
          Write-Host "Publishing TradeExecutor..." -ForegroundColor Cyan
          dotnet publish "$(Build.SourcesDirectory)\src\DerivCTrader.TradeExecutor\DerivCTrader.TradeExecutor.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$(Build.ArtifactStagingDirectory)\tradeexecutor"
          
          if ($LASTEXITCODE -ne 0) { exit 1 }
          Write-Host "✅ TradeExecutor published" -ForegroundColor Green

    # Verify builds
    - task: PowerShell@2
      displayName: 'Verify Build Output'
      inputs:
        targetType: inline
        script: |
          Write-Host "`nVerifying builds..." -ForegroundColor Cyan
          
          # Check SignalScraper
          $scraperExe = Test-Path "$(Build.ArtifactStagingDirectory)\signalscraper\DerivCTrader.SignalScraper.exe"
          if ($scraperExe) {
            Write-Host "✅ SignalScraper.exe found" -ForegroundColor Green
          } else {
            Write-Error "❌ SignalScraper.exe not found"
            exit 1
          }
          
          # Check TradeExecutor
          $executorExe = Test-Path "$(Build.ArtifactStagingDirectory)\tradeexecutor\DerivCTrader.TradeExecutor.exe"
          if ($executorExe) {
            Write-Host "✅ TradeExecutor.exe found" -ForegroundColor Green
          } else {
            Write-Error "❌ TradeExecutor.exe not found"
            exit 1
          }
          
          Write-Host "`n✅ All builds verified" -ForegroundColor Green

  # ================================
  # DEPLOY JOB
  # ================================
  - job: Deploy
    displayName: 'Deploy to VPS'
    dependsOn: Build
    condition: succeeded()
    pool:
      name: 'Default'
    steps:
    - checkout: none  # Don't need source code for deployment
    
    # Download build artifacts from previous job
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'specific'
        downloadPath: '$(System.ArtifactsDirectory)'

    - task: PowerShell@2
      displayName: 'Verify Downloaded Artifacts'
      inputs:
        targetType: inline
        script: |
          Write-Host "Checking artifacts..." -ForegroundColor Cyan
          Write-Host "Artifacts directory: $(System.ArtifactsDirectory)"
          
          if (Test-Path "$(System.ArtifactsDirectory)") {
            Get-ChildItem "$(System.ArtifactsDirectory)" -Recurse | Select-Object FullName
          } else {
            Write-Error "Artifacts directory not found!"
            exit 1
          }

    - task: PowerShell@2
      displayName: 'Test VPS Connection'
      inputs:
        targetType: inline
        script: |
          Write-Host "Testing connection to $(vpsServer)..." -ForegroundColor Cyan
          
          $server = "$(vpsServer)"
          $user = "$(deployUser)"
          $found = $false
          
          $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
          $cred = New-Object PSCredential ($user, $secPass)
          
          try {
            $session = New-PSSession -ComputerName $server -Credential $cred -Authentication Negotiate -ErrorAction Stop
            Write-Host "✅ Connected successfully" -ForegroundColor Green
            Write-Host "##vso[task.setvariable variable=VPSConnected;]true"
            Remove-PSSession $session
          } catch {
            Write-Error "❌ Connection failed: $_"
            exit 1
          }

    - task: PowerShell@2
      displayName: 'Deploy SignalScraper'
      condition: eq(variables['VPSConnected'], 'true')
      inputs:
        targetType: inline
        script: |
          Write-Host ("=" * 80)
          Write-Host "DEPLOYING SIGNALSCRAPER" -ForegroundColor Cyan
          Write-Host ("=" * 80)
          
          $server = "$(vpsServer)"
          $deployPath = "$(deployPathScraper)"
          $serviceName = "$(serviceNameScraper)"
          $artifactPath = "$(System.ArtifactsDirectory)\signalscraper"
          
          Write-Host "Source: $artifactPath"
          Write-Host "Target: $deployPath"
          
          # Verify artifact exists locally
          if (!(Test-Path $artifactPath)) {
            Write-Error "Artifact not found at: $artifactPath"
            Get-ChildItem "$(System.ArtifactsDirectory)" -Recurse
            exit 1
          }
          
          $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
          $cred = New-Object PSCredential ("$(deployUser)", $secPass)
          $session = New-PSSession -ComputerName $server -Credential $cred -Authentication Negotiate
          
          try {
            # Stop service
            Write-Host "`nStopping service..."
            Invoke-Command -Session $session -ScriptBlock {
              param($svc)
              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service -and $service.Status -eq 'Running') {
                Stop-Service -Name $svc -Force
                Start-Sleep -Seconds 3
                Write-Host "✅ Service stopped"
              }
            } -ArgumentList $serviceName
            
            # Backup session files
            Write-Host "Backing up session files..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              if (Test-Path $path) {
                $backup = "$path\session_backup"
                if (!(Test-Path $backup)) { New-Item -ItemType Directory -Path $backup -Force | Out-Null }
                Get-ChildItem -Path $path -Filter "*.session" -ErrorAction SilentlyContinue | 
                  ForEach-Object { Copy-Item $_.FullName -Destination $backup -Force }
              }
            } -ArgumentList $deployPath
            
            # Prepare directory
            Write-Host "Preparing directory..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              if (!(Test-Path $path)) { New-Item -ItemType Directory -Path $path -Force | Out-Null }
              Get-ChildItem -Path $path | Where-Object { 
                $_.Name -notmatch 'log|backup|\.session|charts' 
              } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
            } -ArgumentList $deployPath
            
            # Copy files
            Write-Host "Copying files..."
            Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
            Write-Host "✅ Files copied"
            
            # Restore sessions
            Write-Host "Restoring session files..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              $backup = "$path\session_backup"
              if (Test-Path $backup) {
                Get-ChildItem -Path $backup -Filter "*.session" | 
                  ForEach-Object { Copy-Item $_.FullName -Destination $path -Force }
              }
            } -ArgumentList $deployPath
            
            # Install/start service
            Write-Host "Starting service..."
            Invoke-Command -Session $session -ScriptBlock {
              param($svc, $path)
              
              $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                Where-Object { $_.Name -notlike "createdump*" } |
                Sort-Object Length -Descending | Select-Object -First 1
              
              if (!$exe) { throw "Executable not found" }
              
              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service) {
                sc.exe config $svc binPath= "`"$($exe.FullName)`"" start= auto | Out-Null
              } else {
                New-Service -Name $svc -BinaryPathName $exe.FullName -DisplayName "Deriv cTrader Signal Scraper" -StartupType Automatic | Out-Null
              }
              
              Start-Service -Name $svc -ErrorAction Stop
              Start-Sleep -Seconds 3
              
              $status = (Get-Service -Name $svc).Status
              Write-Host "Service status: $status"
            } -ArgumentList $serviceName, $deployPath
            
            Write-Host "`n✅ SignalScraper deployed successfully" -ForegroundColor Green
            
          } finally {
            Remove-PSSession $session
          }

    - task: PowerShell@2
      displayName: 'Deploy TradeExecutor'
      condition: eq(variables['VPSConnected'], 'true')
      inputs:
        targetType: inline
        script: |
          Write-Host ("=" * 80)
          Write-Host "DEPLOYING TRADEEXECUTOR" -ForegroundColor Cyan
          Write-Host ("=" * 80)
          
          $server = "$(vpsServer)"
          $deployPath = "$(deployPathExecutor)"
          $serviceName = "$(serviceNameExecutor)"
          $artifactPath = "$(System.ArtifactsDirectory)\tradeexecutor"
          
          Write-Host "Source: $artifactPath"
          Write-Host "Target: $deployPath"
          
          if (!(Test-Path $artifactPath)) {
            Write-Error "Artifact not found at: $artifactPath"
            exit 1
          }
          
          $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
          $cred = New-Object PSCredential ("$(deployUser)", $secPass)
          $session = New-PSSession -ComputerName $server -Credential $cred -Authentication Negotiate
          
          try {
            # Stop service
            Write-Host "`nStopping service..."
            Invoke-Command -Session $session -ScriptBlock {
              param($svc)
              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service -and $service.Status -eq 'Running') {
                Stop-Service -Name $svc -Force
                Start-Sleep -Seconds 3
                Write-Host "✅ Service stopped"
              }
            } -ArgumentList $serviceName
            
            # Prepare directory
            Write-Host "Preparing directory..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              if (!(Test-Path $path)) { New-Item -ItemType Directory -Path $path -Force | Out-Null }
              Get-ChildItem -Path $path | Where-Object { 
                $_.Name -notmatch 'log|backup|charts' 
              } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
            } -ArgumentList $deployPath
            
            # Copy files
            Write-Host "Copying files..."
            Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
            Write-Host "✅ Files copied"
            
            # Install/start service
            Write-Host "Starting service..."
            Invoke-Command -Session $session -ScriptBlock {
              param($svc, $path)
              
              $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                Where-Object { $_.Name -notlike "createdump*" } |
                Sort-Object Length -Descending | Select-Object -First 1
              
              if (!$exe) { throw "Executable not found" }
              
              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service) {
                sc.exe config $svc binPath= "`"$($exe.FullName)`"" start= auto | Out-Null
              } else {
                New-Service -Name $svc -BinaryPathName $exe.FullName -DisplayName "Deriv cTrader Trade Executor" -StartupType Automatic | Out-Null
              }
              
              Start-Service -Name $svc -ErrorAction Stop
              Start-Sleep -Seconds 3
              
              $status = (Get-Service -Name $svc).Status
              Write-Host "Service status: $status"
            } -ArgumentList $serviceName, $deployPath
            
            Write-Host "`n✅ TradeExecutor deployed successfully" -ForegroundColor Green
            
          } finally {
            Remove-PSSession $session
          }

    - task: PowerShell@2
      displayName: 'Send Telegram Notification'
      condition: always()
      inputs:
        targetType: inline
        script: |
          $status = if ("$env:AGENT_JOBSTATUS" -eq "Succeeded") { "✅ SUCCESS" } else { "❌ FAILED" }
          $message = "*DerivCTrader Deployment*`n`nStatus: $status`nServer: $(vpsServer)`nBuild: $(Build.BuildNumber)"
          
          $url = "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage"
          $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
          
          try {
            Invoke-RestMethod -Uri $url -Method Post -ContentType "application/json; charset=utf-8" -Body ([System.Text.Encoding]::UTF8.GetBytes($body))
            Write-Host "✅ Notification sent"
          } catch {
            Write-Warning "Notification failed"
          }