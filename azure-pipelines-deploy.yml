# ========================================================
# Azure DevOps Pipeline for DerivCTraderAutomation
# Windows Service Deployment
# FIXED - Matches KhulaFxTradeMonitor Authentication
# ========================================================

trigger:
  branches:
    include:
      - master
      - main

variables:
  - group: Deployment-Secrets
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '8.x'
  - name: serviceNameScraper
    value: 'DerivCTraderSignalScraper'
  - name: serviceNameExecutor
    value: 'DerivCTraderTradeExecutor'
  - name: deployPathScraper
    value: 'C:\Services\DerivCTraderSignalScraper'
  - name: deployPathExecutor
    value: 'C:\Services\DerivCTraderTradeExecutor'
  - name: vpsServer
    value: '108.181.161.170'

stages:
# ================================
# BUILD STAGE
# ================================
- stage: Build
  displayName: 'Build DerivCTrader Services'
  jobs:
  - job: BuildJob
    displayName: 'Build Applications'
    pool:
      name: 'Default'
    steps:
    - checkout: self
      fetchDepth: 1

    - task: UseDotNet@2
      displayName: 'Install .NET SDK 8.x'
      inputs:
        packageType: sdk
        version: $(dotnetVersion)

    # -----------------------------
    # Publish SignalScraper Service
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Publish SignalScraper Service'
      inputs:
        targetType: inline
        script: |
          $publishFolder = "$(Build.ArtifactStagingDirectory)\signalscraper"
          Write-Host "Publishing SignalScraper to $publishFolder"

          dotnet publish "$(Build.SourcesDirectory)\src\DerivCTrader.SignalScraper\DerivCTrader.SignalScraper.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$publishFolder"

          if (!(Test-Path $publishFolder)) {
            Write-Error "Publish folder not found: $publishFolder"
            exit 1
          }

    # -----------------------------
    # Publish TradeExecutor Service
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Publish TradeExecutor Service'
      inputs:
        targetType: inline
        script: |
          $publishFolder = "$(Build.ArtifactStagingDirectory)\tradeexecutor"
          Write-Host "Publishing TradeExecutor to $publishFolder"

          dotnet publish "$(Build.SourcesDirectory)\src\DerivCTrader.TradeExecutor\DerivCTrader.TradeExecutor.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$publishFolder"

          if (!(Test-Path $publishFolder)) {
            Write-Error "Publish folder not found: $publishFolder"
            exit 1
          }

    # -----------------------------
    # Verify Build Output
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Verify SignalScraper Build'
      inputs:
        targetType: inline
        script: |
          $artifactPath = "$(Build.ArtifactStagingDirectory)\signalscraper"
          
          $dllPath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.SignalScraper.dll" -Recurse | Select-Object -First 1
          if ($dllPath) {
            Write-Host "✅ DLL found: $($dllPath.FullName)" -ForegroundColor Green
          } else {
            Write-Error "❌ DerivCTrader.SignalScraper.dll not found"
            exit 1
          }

    - task: PowerShell@2
      displayName: 'Verify TradeExecutor Build'
      inputs:
        targetType: inline
        script: |
          $artifactPath = "$(Build.ArtifactStagingDirectory)\tradeexecutor"
          
          $dllPath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.TradeExecutor.dll" -Recurse | Select-Object -First 1
          if ($dllPath) {
            Write-Host "✅ DLL found: $($dllPath.FullName)" -ForegroundColor Green
          } else {
            Write-Error "❌ DerivCTrader.TradeExecutor.dll not found"
            exit 1
          }

    # -----------------------------
    # Publish Artifacts
    # -----------------------------
    - task: PublishBuildArtifacts@1
      displayName: 'Publish SignalScraper Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/signalscraper'
        artifactName: 'signalscraper'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish TradeExecutor Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/tradeexecutor'
        artifactName: 'tradeexecutor'
        publishLocation: 'Container'

# ================================
# DEPLOY STAGE
# ================================
- stage: Deploy
  displayName: 'Deploy to VPS'
  dependsOn: Build
  jobs:
  - deployment: DeployServices
    displayName: 'Deploy Both Services'
    environment: 'VPS-Production'
    pool:
      name: 'Default'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: signalscraper

          - download: current
            artifact: tradeexecutor

          # ================================
          # AUTHENTICATION - EXACT COPY FROM KhulaFxTradeMonitor
          # ================================
          - task: PowerShell@2
            displayName: 'Test Authentication'
            inputs:
              targetType: inline
              script: |
                $server = "$(vpsServer)"
                $usernameVariants = @(".\$(deployUser)", "$(deployUser)")
                $authMethods = @("Negotiate", "Default")
                $found = $false

                foreach ($auth in $authMethods) {
                  foreach ($user in $usernameVariants) {
                    Write-Host "Trying $auth as $user..."
                    try {
                      $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                      $cred = New-Object PSCredential ($user, $secPass)
                      $s = New-PSSession -ComputerName $server -Authentication $auth -Credential $cred -ErrorAction Stop
                      Write-Host "✅ Success with $auth as $user"
                      Write-Host "##vso[task.setvariable variable=SuccessfulUserName;isOutput=true]$user"
                      Write-Host "##vso[task.setvariable variable=SuccessfulAuth;isOutput=true]$auth"
                      Remove-PSSession $s
                      $found = $true
                      break
                    } catch {
                      Write-Host "❌ Failed"
                    }
                  }
                  if ($found) { break }
                }

                if (-not $found) {
                  Write-Error "Authentication failed"
                  exit 1
                }
            name: AuthTest

          # ================================
          # Deploy SignalScraper Service
          # ================================
          - task: PowerShell@2
            displayName: 'Deploy SignalScraper Service'
            inputs:
              targetType: inline
              script: |
                $server = "$(vpsServer)"
                $deployPath = "$(deployPathScraper)"
                $serviceName = "$(serviceNameScraper)"
                $artifactPath = "$(Pipeline.Workspace)/signalscraper"

                Write-Host "Deploying to: $deployPath"

                $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
                $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)

                try {
                  # Stop service
                  Write-Host "Stopping service..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($svc)
                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service -and $service.Status -eq 'Running') {
                      Stop-Service -Name $svc -Force
                      Start-Sleep -Seconds 5
                      Write-Host "Service stopped"
                    }
                  } -ArgumentList $serviceName

                  # Backup session files
                  Write-Host "Backing up Telegram session files..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    if (Test-Path $path) {
                      $backupPath = "$path\session_backup"
                      if (-not (Test-Path $backupPath)) { 
                        New-Item -ItemType Directory -Path $backupPath -Force | Out-Null 
                      }
                      Get-ChildItem -Path $path -Filter "*.session" | ForEach-Object {
                        Copy-Item $_.FullName -Destination $backupPath -Force
                        Write-Host "Backed up: $($_.Name)"
                      }
                    }
                  } -ArgumentList $deployPath

                  # Prepare directory
                  Write-Host "Preparing directory..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    if (-not (Test-Path $path)) { New-Item -ItemType Directory -Path $path -Force | Out-Null }
                    Get-ChildItem -Path $path | Where-Object { $_.Name -notmatch 'log|backup|\.session|charts' } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                    Write-Host "Directory ready"
                  } -ArgumentList $deployPath

                  # Copy files
                  Write-Host "Copying files..."
                  Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
                  Write-Host "Files copied"

                  # Restore session files
                  Write-Host "Restoring Telegram session files..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    $backupPath = "$path\session_backup"
                    if (Test-Path $backupPath) {
                      Get-ChildItem -Path $backupPath -Filter "*.session" | ForEach-Object {
                        Copy-Item $_.FullName -Destination $path -Force
                        Write-Host "Restored: $($_.Name)"
                      }
                    }
                  } -ArgumentList $deployPath

                  # Install/start service
                  Write-Host "Starting service..."
                  $result = Invoke-Command -Session $session -ScriptBlock {
                    param($svc, $path)
                    
                    $exe = Get-ChildItem -Path $path -Filter "DerivCTrader.SignalScraper.exe" -ErrorAction SilentlyContinue
                    if (-not $exe) {
                      $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                        Where-Object { $_.Name -notlike "createdump*" } |
                        Sort-Object Length -Descending | 
                        Select-Object -First 1
                    }
                    if (-not $exe) { throw "Executable not found" }

                    $binaryPath = $exe.FullName
                    Write-Host "Executable: $binaryPath"

                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service) {
                      Write-Host "Updating existing service..."
                      sc.exe config $svc binPath= "`"$binaryPath`"" start= auto | Out-Null
                    } else {
                      Write-Host "Creating new service..."
                      New-Service -Name $svc -BinaryPathName $binaryPath -DisplayName "Deriv cTrader Signal Scraper" -StartupType Automatic | Out-Null
                    }

                    Write-Host "Attempting to start service..."
                    try {
                      Start-Service -Name $svc -ErrorAction Stop
                      Start-Sleep -Seconds 5
                      
                      $status = (Get-Service -Name $svc).Status
                      if ($status -eq 'Running') {
                        Write-Host "✅ Service running"
                        return @{ Success = $true; Status = $status }
                      } else {
                        Write-Host "⚠️ Service status: $status"
                        return @{ Success = $false; Status = $status; Error = "Service not running after 5 seconds" }
                      }
                    } catch {
                      Write-Host "❌ Service failed to start: $_"
                      return @{ Success = $false; Status = "Stopped"; Error = $_.Exception.Message }
                    }
                  } -ArgumentList $serviceName, $deployPath

                  if (-not $result.Success) {
                    Write-Warning "Service deployment completed but service is not running"
                    Write-Warning "Error: $($result.Error)"
                  }
                } finally {
                  Remove-PSSession $session
                }

          # ================================
          # Deploy TradeExecutor Service
          # ================================
          - task: PowerShell@2
            displayName: 'Deploy TradeExecutor Service'
            inputs:
              targetType: inline
              script: |
                $server = "$(vpsServer)"
                $deployPath = "$(deployPathExecutor)"
                $serviceName = "$(serviceNameExecutor)"
                $artifactPath = "$(Pipeline.Workspace)/tradeexecutor"

                Write-Host "Deploying to: $deployPath"

                $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
                $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)

                try {
                  # Stop service
                  Write-Host "Stopping service..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($svc)
                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service -and $service.Status -eq 'Running') {
                      Stop-Service -Name $svc -Force
                      Start-Sleep -Seconds 5
                      Write-Host "Service stopped"
                    }
                  } -ArgumentList $serviceName

                  # Prepare directory
                  Write-Host "Preparing directory..."
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    if (-not (Test-Path $path)) { New-Item -ItemType Directory -Path $path -Force | Out-Null }
                    Get-ChildItem -Path $path | Where-Object { $_.Name -notmatch 'log|backup|charts' } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                    Write-Host "Directory ready"
                  } -ArgumentList $deployPath

                  # Copy files
                  Write-Host "Copying files..."
                  Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
                  Write-Host "Files copied"

                  # Install/start service
                  Write-Host "Starting service..."
                  $result = Invoke-Command -Session $session -ScriptBlock {
                    param($svc, $path)
                    
                    $exe = Get-ChildItem -Path $path -Filter "DerivCTrader.TradeExecutor.exe" -ErrorAction SilentlyContinue
                    if (-not $exe) {
                      $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                        Where-Object { $_.Name -notlike "createdump*" } |
                        Sort-Object Length -Descending | 
                        Select-Object -First 1
                    }
                    if (-not $exe) { throw "Executable not found" }

                    $binaryPath = $exe.FullName
                    Write-Host "Executable: $binaryPath"

                    $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
                    if ($service) {
                      Write-Host "Updating existing service..."
                      sc.exe config $svc binPath= "`"$binaryPath`"" start= auto | Out-Null
                    } else {
                      Write-Host "Creating new service..."
                      New-Service -Name $svc -BinaryPathName $binaryPath -DisplayName "Deriv cTrader Trade Executor" -StartupType Automatic | Out-Null
                    }

                    Write-Host "Attempting to start service..."
                    try {
                      Start-Service -Name $svc -ErrorAction Stop
                      Start-Sleep -Seconds 5
                      
                      $status = (Get-Service -Name $svc).Status
                      if ($status -eq 'Running') {
                        Write-Host "✅ Service running"
                        return @{ Success = $true; Status = $status }
                      } else {
                        Write-Host "⚠️ Service status: $status"
                        return @{ Success = $false; Status = $status; Error = "Service not running after 5 seconds" }
                      }
                    } catch {
                      Write-Host "❌ Service failed to start: $_"
                      return @{ Success = $false; Status = "Stopped"; Error = $_.Exception.Message }
                    }
                  } -ArgumentList $serviceName, $deployPath

                  if (-not $result.Success) {
                    Write-Warning "Service deployment completed but service is not running"
                    Write-Warning "Error: $($result.Error)"
                  }
                } finally {
                  Remove-PSSession $session
                }

          # ================================
          # Check Application Logs
          # ================================
          - task: PowerShell@2
            displayName: 'Check SignalScraper Logs'
            condition: always()
            inputs:
              targetType: inline
              script: |
                Write-Host "Checking application logs..."
                $server = "$(vpsServer)"
                $deployPath = "$(deployPathScraper)"
                
                $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
                
                try {
                  $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)
                  
                  Invoke-Command -Session $session -ScriptBlock {
                    param($path)
                    
                    $logPath = Join-Path $path "Logs"
                    
                    if (Test-Path $logPath) {
                      $latestLog = Get-ChildItem -Path $logPath -Filter "*.txt" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                      
                      if ($latestLog) {
                        Write-Host "`nLatest log file: $($latestLog.Name)"
                        Write-Host "Last 30 lines:"
                        Write-Host "=" * 80
                        Get-Content $latestLog.FullName -Tail 30
                        Write-Host "=" * 80
                      } else {
                        Write-Host "No log files found in Logs directory"
                      }
                    } else {
                      Write-Host "Logs directory not found at: $logPath"
                      Write-Host "This is normal if service hasn't started yet"
                    }
                  } -ArgumentList $deployPath
                  
                  Remove-PSSession $session
                } catch {
                  Write-Warning "Could not read logs: $_"
                }

# ================================
# NOTIFY STAGE
# ================================
- stage: Notify
  displayName: 'Send Notification'
  dependsOn: Deploy
  condition: always()
  jobs:
  - job: SendNotification
    pool:
      name: 'Default'
    steps:
    - task: PowerShell@2
      displayName: 'Telegram Notification'
      inputs:
        targetType: inline
        script: |
          $status = if ("$(Agent.JobStatus)" -eq "Succeeded") { "✅ SUCCESS" } else { "❌ FAILED" }
          $message = @"
          *DerivCTrader Deployment*
          
          Status: $status
          Server: $(vpsServer)
          Path (Scraper): $(deployPathScraper)
          Path (Executor): $(deployPathExecutor)
          Build: $(Build.BuildNumber)
          
          [View Logs]($(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId))
          "@
          
          $url = "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage"
          $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
          
          try {
            Invoke-RestMethod -Uri $url -Method Post -ContentType "application/json; charset=utf-8" -Body ([System.Text.Encoding]::UTF8.GetBytes($body))
            Write-Host "✅ Notification sent"
          } catch {
            Write-Warning "Notification failed"
          }