# ========================================================
# Azure DevOps Pipeline for DerivCTraderAutomation
# Windows Service Deployment
# ========================================================

trigger:
  branches:
    include:
      - master
      - main

variables:
  - group: Deployment-Secrets
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '8.x'
  - name: serviceNameScraper
    value: 'DerivCTraderSignalScraper'
  - name: serviceNameExecutor
    value: 'DerivCTraderTradeExecutor'
  - name: deployPathScraper
    value: 'C:\Services\DerivCTraderSignalScraper'
  - name: deployPathExecutor
    value: 'C:\Services\DerivCTraderTradeExecutor'
  - name: vpsServer
    value: '108.181.161.170'

stages:
# ================================
# BUILD STAGE
# ================================
- stage: Build
  displayName: 'Build DerivCTrader Services'
  jobs:
  - job: BuildJob
    displayName: 'Build Applications'
    pool:
      name: 'Default'
    steps:
    - checkout: self
      fetchDepth: 1

    - task: UseDotNet@2
      displayName: 'Install .NET SDK 8.x'
      inputs:
        packageType: sdk
        version: $(dotnetVersion)

    # -----------------------------
    # Publish SignalScraper Service
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Publish SignalScraper Service'
      inputs:
        targetType: inline
        script: |
          $publishFolder = "$(Build.ArtifactStagingDirectory)\signalscraper"
          Write-Host "Publishing SignalScraper to $publishFolder"

          dotnet publish ".\src\DerivCTrader.SignalScraper\DerivCTrader.SignalScraper.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$publishFolder"

          if (!(Test-Path $publishFolder)) {
            Write-Error "Publish folder not found: $publishFolder"
            exit 1
          }

    # -----------------------------
    # Publish TradeExecutor Service
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Publish TradeExecutor Service'
      inputs:
        targetType: inline
        script: |
          $publishFolder = "$(Build.ArtifactStagingDirectory)\tradeexecutor"
          Write-Host "Publishing TradeExecutor to $publishFolder"

          dotnet publish ".\src\DerivCTrader.TradeExecutor\DerivCTrader.TradeExecutor.csproj" `
            -c $(buildConfiguration) `
            -r win-x64 `
            --self-contained true `
            -o "$publishFolder"

          if (!(Test-Path $publishFolder)) {
            Write-Error "Publish folder not found: $publishFolder"
            exit 1
          }

    # -----------------------------
    # Copy Telegram Session Files (if they exist)
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Preserve Telegram Session Files'
      inputs:
        targetType: inline
        script: |
          $publishFolder = "$(Build.ArtifactStagingDirectory)\signalscraper"
          
          Write-Host "Note: Telegram session files (DerivCTrader.session, DerivCTrader2.session) should be preserved on VPS during deployment"
          Write-Host "Session files are NOT included in build artifacts - they remain on the server"

    # -----------------------------
    # Verify SignalScraper Build Output
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Verify SignalScraper Build'
      inputs:
        targetType: inline
        script: |
          $artifactPath = "$(Build.ArtifactStagingDirectory)\signalscraper"
          
          # Check for EXE
          $exePath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.SignalScraper.exe" -Recurse | Select-Object -First 1
          if ($exePath) {
            Write-Host "‚úÖ EXE found: $($exePath.FullName)" -ForegroundColor Green
            Write-Host "   Size: $([math]::Round($exePath.Length / 1MB, 2)) MB"
          } else {
            Write-Warning "‚ö†Ô∏è DerivCTrader.SignalScraper.exe not found"
          }
          
          # Check for DLL
          $dllPath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.SignalScraper.dll" -Recurse | Select-Object -First 1
          if ($dllPath) {
            Write-Host "‚úÖ DLL found: $($dllPath.FullName)" -ForegroundColor Green
            Write-Host "   Size: $([math]::Round($dllPath.Length / 1MB, 2)) MB"
          } else {
            Write-Error "‚ùå DerivCTrader.SignalScraper.dll not found"
            exit 1
          }

          # Check for appsettings
          $configPath = Get-ChildItem -Path $artifactPath -Filter "appsettings.Production.json" | Select-Object -First 1
          if ($configPath) {
            Write-Host "‚úÖ Production config found: $($configPath.FullName)" -ForegroundColor Green
          } else {
            Write-Warning "‚ö†Ô∏è appsettings.Production.json not found"
          }

    # -----------------------------
    # Verify TradeExecutor Build Output
    # -----------------------------
    - task: PowerShell@2
      displayName: 'Verify TradeExecutor Build'
      inputs:
        targetType: inline
        script: |
          $artifactPath = "$(Build.ArtifactStagingDirectory)\tradeexecutor"
          
          # Check for EXE
          $exePath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.TradeExecutor.exe" -Recurse | Select-Object -First 1
          if ($exePath) {
            Write-Host "‚úÖ EXE found: $($exePath.FullName)" -ForegroundColor Green
            Write-Host "   Size: $([math]::Round($exePath.Length / 1MB, 2)) MB"
          } else {
            Write-Warning "‚ö†Ô∏è DerivCTrader.TradeExecutor.exe not found"
          }
          
          # Check for DLL
          $dllPath = Get-ChildItem -Path $artifactPath -Filter "DerivCTrader.TradeExecutor.dll" -Recurse | Select-Object -First 1
          if ($dllPath) {
            Write-Host "‚úÖ DLL found: $($dllPath.FullName)" -ForegroundColor Green
            Write-Host "   Size: $([math]::Round($dllPath.Length / 1MB, 2)) MB"
          } else {
            Write-Error "‚ùå DerivCTrader.TradeExecutor.dll not found"
            exit 1
          }

    # -----------------------------
    # List Deployment Files
    # -----------------------------
    - task: PowerShell@2
      displayName: 'List SignalScraper Deployment Files'
      inputs:
        targetType: inline
        script: |
          Write-Host "`nüì¶ SignalScraper files to be deployed:" -ForegroundColor Cyan
          Write-Host "=" * 80
          $files = Get-ChildItem "$(Build.ArtifactStagingDirectory)\signalscraper" -Recurse -File | 
            ForEach-Object { $_.FullName.Replace('$(Build.ArtifactStagingDirectory)\signalscraper\', '') }
          
          $files | Sort-Object | ForEach-Object { Write-Host "  $_" }
          Write-Host "=" * 80
          Write-Host "Total files: $($files.Count)"

    - task: PowerShell@2
      displayName: 'List TradeExecutor Deployment Files'
      inputs:
        targetType: inline
        script: |
          Write-Host "`nüì¶ TradeExecutor files to be deployed:" -ForegroundColor Cyan
          Write-Host "=" * 80
          $files = Get-ChildItem "$(Build.ArtifactStagingDirectory)\tradeexecutor" -Recurse -File | 
            ForEach-Object { $_.FullName.Replace('$(Build.ArtifactStagingDirectory)\tradeexecutor\', '') }
          
          $files | Sort-Object | ForEach-Object { Write-Host "  $_" }
          Write-Host "=" * 80
          Write-Host "Total files: $($files.Count)"

    # -----------------------------
    # Publish Artifacts
    # -----------------------------
    - task: PublishBuildArtifacts@1
      displayName: 'Publish SignalScraper Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/signalscraper'
        artifactName: 'signalscraper'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish TradeExecutor Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/tradeexecutor'
        artifactName: 'tradeexecutor'
        publishLocation: 'Container'

# ================================
# DEPLOY STAGE
# ================================
- stage: Deploy
  displayName: 'Deploy to VPS'
  dependsOn: Build
  jobs:
  - job: DeployServices
    displayName: 'Deploy Both Services'
    pool:
      name: 'Default'
    steps:
    - download: current
      artifact: signalscraper

    - download: current
      artifact: tradeexecutor

    - task: PowerShell@2
      displayName: 'Test Authentication'
      inputs:
        targetType: inline
        script: |
          $server = "$(vpsServer)"
          $usernameVariants = @(".\$(deployUser)", "$(deployUser)")
          $authMethods = @("Negotiate", "Default")
          $found = $false

          foreach ($auth in $authMethods) {
            foreach ($user in $usernameVariants) {
              Write-Host "Trying $auth as $user..."
              try {
                $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
                $cred = New-Object PSCredential ($user, $secPass)
                $s = New-PSSession -ComputerName $server -Authentication $auth -Credential $cred -ErrorAction Stop
                Write-Host "‚úÖ Success with $auth as $user"
                Write-Host "##vso[task.setvariable variable=SuccessfulUserName;isOutput=true]$user"
                Write-Host "##vso[task.setvariable variable=SuccessfulAuth;isOutput=true]$auth"
                Remove-PSSession $s
                $found = $true
                break
              } catch {
                Write-Host "‚ùå Failed"
              }
            }
            if ($found) { break }
          }

          if (-not $found) {
            Write-Error "Authentication failed"
            exit 1
          }
      name: AuthTest

    # ================================
    # Deploy SignalScraper Service
    # ================================
    - task: PowerShell@2
      displayName: 'Deploy SignalScraper Service'
      inputs:
        targetType: inline
        script: |
          $server = "$(vpsServer)"
          $deployPath = "$(deployPathScraper)"
          $serviceName = "$(serviceNameScraper)"
          $artifactPath = "$(Pipeline.Workspace)/signalscraper"

          Write-Host "=" * 80
          Write-Host "DEPLOYING SIGNALSCRAPER SERVICE" -ForegroundColor Cyan
          Write-Host "=" * 80
          Write-Host "Target: $deployPath"

          $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
          $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
          $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)

          try {
            # Stop service
            Write-Host "`nüõë Stopping service..."
            Invoke-Command -Session $session -ScriptBlock {
              param($svc)
              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service -and $service.Status -eq 'Running') {
                Stop-Service -Name $svc -Force
                Start-Sleep -Seconds 5
                Write-Host "‚úÖ Service stopped"
              } else {
                Write-Host "‚ÑπÔ∏è Service not running"
              }
            } -ArgumentList $serviceName

            # Backup session files
            Write-Host "`nüíæ Backing up Telegram session files..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              if (Test-Path $path) {
                $backupPath = "$path\session_backup"
                if (-not (Test-Path $backupPath)) { 
                  New-Item -ItemType Directory -Path $backupPath -Force | Out-Null 
                }
                
                # Backup any .session files
                Get-ChildItem -Path $path -Filter "*.session" | ForEach-Object {
                  Copy-Item $_.FullName -Destination $backupPath -Force
                  Write-Host "‚úÖ Backed up: $($_.Name)"
                }
              }
            } -ArgumentList $deployPath

            # Prepare directory (preserve session files, logs, backups)
            Write-Host "`nüìÇ Preparing directory..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              if (-not (Test-Path $path)) { 
                New-Item -ItemType Directory -Path $path -Force | Out-Null 
              }
              
              # Remove old files but preserve session files, logs, and backups
              Get-ChildItem -Path $path | Where-Object { 
                $_.Name -notmatch 'log|backup|\.session|charts' 
              } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
              
              Write-Host "‚úÖ Directory ready"
            } -ArgumentList $deployPath

            # Copy new files
            Write-Host "`nüì¶ Copying new files..."
            Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
            Write-Host "‚úÖ Files copied"

            # Restore session files
            Write-Host "`n‚ôªÔ∏è Restoring Telegram session files..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              $backupPath = "$path\session_backup"
              if (Test-Path $backupPath) {
                Get-ChildItem -Path $backupPath -Filter "*.session" | ForEach-Object {
                  Copy-Item $_.FullName -Destination $path -Force
                  Write-Host "‚úÖ Restored: $($_.Name)"
                }
              } else {
                Write-Host "‚ÑπÔ∏è No session backup found (first deployment)"
              }
            } -ArgumentList $deployPath

            # Install/start service
            Write-Host "`nüöÄ Starting service..."
            $result = Invoke-Command -Session $session -ScriptBlock {
              param($svc, $path)
              
              $exe = Get-ChildItem -Path $path -Filter "DerivCTrader.SignalScraper.exe" -ErrorAction SilentlyContinue
              if (-not $exe) {
                $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                  Where-Object { $_.Name -notlike "createdump*" } |
                  Sort-Object Length -Descending | 
                  Select-Object -First 1
              }
              if (-not $exe) { throw "Executable not found" }

              $binaryPath = $exe.FullName
              Write-Host "Executable: $binaryPath"

              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service) {
                Write-Host "Updating existing service..."
                sc.exe config $svc binPath= "`"$binaryPath`"" start= auto | Out-Null
              } else {
                Write-Host "Creating new service..."
                New-Service -Name $svc -BinaryPathName $binaryPath -DisplayName "Deriv cTrader Signal Scraper" -StartupType Automatic | Out-Null
              }

              Write-Host "Starting service..."
              try {
                Start-Service -Name $svc -ErrorAction Stop
                Start-Sleep -Seconds 5
                
                $status = (Get-Service -Name $svc).Status
                if ($status -eq 'Running') {
                  Write-Host "‚úÖ Service running"
                  return @{ Success = $true; Status = $status }
                } else {
                  Write-Host "‚ö†Ô∏è Service status: $status"
                  return @{ Success = $false; Status = $status; Error = "Service not running" }
                }
              } catch {
                Write-Host "‚ùå Service failed to start: $_"
                return @{ Success = $false; Status = "Stopped"; Error = $_.Exception.Message }
              }
            } -ArgumentList $serviceName, $deployPath

            if (-not $result.Success) {
              Write-Warning "‚ö†Ô∏è SignalScraper service not running - may need manual start"
            }
          } finally {
            Remove-PSSession $session
          }

    # ================================
    # Deploy TradeExecutor Service
    # ================================
    - task: PowerShell@2
      displayName: 'Deploy TradeExecutor Service'
      inputs:
        targetType: inline
        script: |
          $server = "$(vpsServer)"
          $deployPath = "$(deployPathExecutor)"
          $serviceName = "$(serviceNameExecutor)"
          $artifactPath = "$(Pipeline.Workspace)/tradeexecutor"

          Write-Host "=" * 80
          Write-Host "DEPLOYING TRADEEXECUTOR SERVICE" -ForegroundColor Cyan
          Write-Host "=" * 80
          Write-Host "Target: $deployPath"

          $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
          $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
          $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)

          try {
            # Stop service
            Write-Host "`nüõë Stopping service..."
            Invoke-Command -Session $session -ScriptBlock {
              param($svc)
              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service -and $service.Status -eq 'Running') {
                Stop-Service -Name $svc -Force
                Start-Sleep -Seconds 5
                Write-Host "‚úÖ Service stopped"
              } else {
                Write-Host "‚ÑπÔ∏è Service not running"
              }
            } -ArgumentList $serviceName

            # Prepare directory
            Write-Host "`nüìÇ Preparing directory..."
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              if (-not (Test-Path $path)) { 
                New-Item -ItemType Directory -Path $path -Force | Out-Null 
              }
              Get-ChildItem -Path $path | Where-Object { 
                $_.Name -notmatch 'log|backup|charts' 
              } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
              Write-Host "‚úÖ Directory ready"
            } -ArgumentList $deployPath

            # Copy files
            Write-Host "`nüì¶ Copying new files..."
            Copy-Item -Path "$artifactPath\*" -Destination $deployPath -ToSession $session -Recurse -Force
            Write-Host "‚úÖ Files copied"

            # Install/start service
            Write-Host "`nüöÄ Starting service..."
            $result = Invoke-Command -Session $session -ScriptBlock {
              param($svc, $path)
              
              $exe = Get-ChildItem -Path $path -Filter "DerivCTrader.TradeExecutor.exe" -ErrorAction SilentlyContinue
              if (-not $exe) {
                $exe = Get-ChildItem -Path $path -Filter "*.exe" | 
                  Where-Object { $_.Name -notlike "createdump*" } |
                  Sort-Object Length -Descending | 
                  Select-Object -First 1
              }
              if (-not $exe) { throw "Executable not found" }

              $binaryPath = $exe.FullName
              Write-Host "Executable: $binaryPath"

              $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
              if ($service) {
                Write-Host "Updating existing service..."
                sc.exe config $svc binPath= "`"$binaryPath`"" start= auto | Out-Null
              } else {
                Write-Host "Creating new service..."
                New-Service -Name $svc -BinaryPathName $binaryPath -DisplayName "Deriv cTrader Trade Executor" -StartupType Automatic | Out-Null
              }

              Write-Host "Starting service..."
              try {
                Start-Service -Name $svc -ErrorAction Stop
                Start-Sleep -Seconds 5
                
                $status = (Get-Service -Name $svc).Status
                if ($status -eq 'Running') {
                  Write-Host "‚úÖ Service running"
                  return @{ Success = $true; Status = $status }
                } else {
                  Write-Host "‚ö†Ô∏è Service status: $status"
                  return @{ Success = $false; Status = $status; Error = "Service not running" }
                }
              } catch {
                Write-Host "‚ùå Service failed to start: $_"
                return @{ Success = $false; Status = "Stopped"; Error = $_.Exception.Message }
              }
            } -ArgumentList $serviceName, $deployPath

            if (-not $result.Success) {
              Write-Warning "‚ö†Ô∏è TradeExecutor service not running - may need manual start"
            }
          } finally {
            Remove-PSSession $session
          }

    # ================================
    # Check Logs
    # ================================
    - task: PowerShell@2
      displayName: 'Check SignalScraper Logs'
      condition: always()
      inputs:
        targetType: inline
        script: |
          Write-Host "Checking SignalScraper logs..." -ForegroundColor Cyan
          $server = "$(vpsServer)"
          $deployPath = "$(deployPathScraper)"
          
          $secPass = ConvertTo-SecureString "$(DEPLOY_PASSWORD)" -AsPlainText -Force
          $cred = New-Object PSCredential ("$(AuthTest.SuccessfulUserName)", $secPass)
          
          try {
            $session = New-PSSession -ComputerName $server -Credential $cred -Authentication $(AuthTest.SuccessfulAuth)
            
            Invoke-Command -Session $session -ScriptBlock {
              param($path)
              
              $logPath = Join-Path $path "logs"
              
              if (Test-Path $logPath) {
                $latestLog = Get-ChildItem -Path $logPath -Filter "*.txt" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                
                if ($latestLog) {
                  Write-Host "`nLatest log: $($latestLog.Name)"
                  Write-Host "Last 30 lines:"
                  Write-Host "=" * 80
                  Get-Content $latestLog.FullName -Tail 30
                  Write-Host "=" * 80
                }
              } else {
                Write-Host "No logs yet (normal for new deployment)"
              }
            } -ArgumentList $deployPath
            
            Remove-PSSession $session
          } catch {
            Write-Warning "Could not read logs: $_"
          }

# ================================
# NOTIFY STAGE
# ================================
- stage: Notify
  displayName: 'Send Notification'
  dependsOn: Deploy
  condition: always()
  jobs:
  - job: SendNotification
    pool:
      name: 'Default'
    steps:
    - task: PowerShell@2
      displayName: 'Telegram Notification'
      inputs:
        targetType: inline
        script: |
          $status = if ("$(Agent.JobStatus)" -eq "Succeeded") { "‚úÖ SUCCESS" } else { "‚ùå FAILED" }
          $message = @"
          *DerivCTrader Deployment*
          
          Status: $status
          Server: $(vpsServer)
          
          Services:
          ‚Ä¢ SignalScraper: $(deployPathScraper)
          ‚Ä¢ TradeExecutor: $(deployPathExecutor)
          
          Build: $(Build.BuildNumber)
          
          [View Logs]($(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId))
          "@
          
          $url = "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage"
          $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
          
          try {
            Invoke-RestMethod -Uri $url -Method Post -ContentType "application/json; charset=utf-8" -Body ([System.Text.Encoding]::UTF8.GetBytes($body))
            Write-Host "‚úÖ Notification sent"
          } catch {
            Write-Warning "Notification failed"
          }
